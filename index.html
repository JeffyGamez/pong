<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Super Pong</title>
<style>
  body {
    margin: 0;
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: white;
    font-family: Arial, sans-serif;
    user-select: none;
  }
  #gameContainer {
    margin-top: 10px;
    position: relative;
  }
  canvas {
    background: black;
    display: block;
  }
  #controls {
    margin-top: 10px;
    display: flex;
    gap: 10px;
  }
  .btn {
    padding: 6px 14px;
    background: blue;
    color: white;
    border: 2px solid white;
    cursor: pointer;
    font-weight: bold;
  }
  .btn.active {
    background: yellow;
    color: black;
  }
</style>
</head>
<body>
<h2>Super Pong</h2>

<div id="controls">
  <button id="slowBtn" class="btn">Slow</button>
  <button id="twoPBtn" class="btn">2P</button>
  <button id="pauseBtn" class="btn">Pause</button>
  <button id="resetBtn" class="btn">Reset</button>
</div>

<div id="gameContainer">
  <canvas id="game" width="800" height="500"></canvas>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const W = canvas.width;
const H = canvas.height;
const midX = W / 2;

// Triangle size
const triSize = 20;

// Paddles
const paddleWidth = 12;
const paddleHeight = 80;
const paddleOffset = 5;
const paddleSpeed = 6;          // Player speed
const aiSpeed = paddleSpeed - 1; // AI is now 1 slower (5)

// Ball
const ballRadius = 8;
const BASE_SPEED = 4;
const SLOW_SPEED = 2;
const FAST_SPEED = 8;
let slowMode = false;
let paused = false;
let twoPlayer = false;

let leftScore = 0;
let rightScore = 0;

let ball = {
  x: midX,
  y: H / 2,
  vx: BASE_SPEED,
  vy: 1.5,
  speed: BASE_SPEED,
  isPower: false
};

let leftPaddle = {
  x: paddleOffset,
  y: H / 2 - paddleHeight / 2,
  vy: paddleSpeed
};

let rightPaddle = {
  x: W - paddleOffset - paddleWidth,
  y: H / 2 - paddleHeight / 2,
  vy: aiSpeed,
  targetY: H / 2
};

// AI frame counter
let aiFrameCounter = 0;

// Trail
const trail = [];
const TRAIL_MAX_POINTS = 30;
const TRAIL_MAX_DIST = 40;

// Flashes
let leftFlash = null;
let rightFlash = null;

// Buttons
const slowBtn = document.getElementById('slowBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const twoPBtn = document.getElementById('twoPBtn');

// Keyboard
const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

function clampPaddle(p) {
  if (p.y < 0) p.y = 0;
  if (p.y + paddleHeight > H) p.y = H - paddleHeight;

  // Prevent paddles from entering triangles
  if (p.y < triSize) p.y = triSize;
  if (p.y + paddleHeight > H - triSize) p.y = H - triSize - paddleHeight;
}

// LEFT PADDLE: W = up, D = down
function handleLeftPaddleInput() {
  if (keys['w'] || keys['W']) leftPaddle.y -= leftPaddle.vy;
  if (keys['d'] || keys['D']) leftPaddle.y += leftPaddle.vy;
  clampPaddle(leftPaddle);
}

// RIGHT PADDLE: Left Arrow = up, Right Arrow = down
function handleRightPaddleInput() {
  if (!twoPlayer) return;

  if (keys['ArrowLeft']) rightPaddle.y -= rightPaddle.vy;
  if (keys['ArrowRight']) rightPaddle.y += rightPaddle.vy;

  clampPaddle(rightPaddle);
}

// AI updates every 50 frames when ball is moving toward it
function updateAI() {
  if (twoPlayer) return;

  // Only update when ball is moving toward AI
  if (ball.vx > 0) {
    aiFrameCounter++;

    if (aiFrameCounter >= 30) {
      aiFrameCounter = 0;

      // 55% hit, 45% miss
      if (Math.random() < 0.55) {
        rightPaddle.targetY = ball.y - paddleHeight / 2;
      } else {
        const offset = (Math.random() * 80 - 40);
        rightPaddle.targetY = ball.y - paddleHeight / 2 + offset;
      }
    }
  }

  // Smooth movement
  if (rightPaddle.targetY < rightPaddle.y) rightPaddle.y -= rightPaddle.vy;
  else if (rightPaddle.targetY > rightPaddle.y) rightPaddle.y += rightPaddle.vy;

  clampPaddle(rightPaddle);
}

function setFlash(side, color) {
  const until = performance.now() + 1000;
  if (side === 'left') leftFlash = { color, until };
  else rightFlash = { color, until };
}

function resetBall(toRight) {
  ball.x = midX;
  ball.y = H / 2;
  ball.isPower = false;
  aiFrameCounter = 0; // reset AI timer
  ball.speed = slowMode ? SLOW_SPEED : BASE_SPEED;
  const angle = 0.3;
  ball.vx = (toRight ? 1 : -1) * ball.speed * Math.cos(angle);
  ball.vy = ball.speed * Math.sin(angle);
  trail.length = 0;
}

function updateBallSpeed() {
  if (ball.isPower) ball.speed = FAST_SPEED;
  else ball.speed = slowMode ? SLOW_SPEED : BASE_SPEED;

  const mag = Math.hypot(ball.vx, ball.vy) || 1;
  ball.vx = (ball.vx / mag) * ball.speed;
  ball.vy = (ball.vy / mag) * ball.speed;
}

// FIREBALL CHANCE = 20%
function maybePowerShot() {
  ball.isPower = Math.random() < 0.2;
  updateBallSpeed();
}

// Reflect vector v across normal n
function reflect(vx, vy, nx, ny) {
  const dot = vx * nx + vy * ny;
  return {
    vx: vx - 2 * dot * nx,
    vy: vy - 2 * dot * ny
  };
}

// Check collision with a line segment
function checkLineCollision(x1, y1, x2, y2) {
  const A = { x: x1, y: y1 };
  const B = { x: x2, y: y2 };
  const P = { x: ball.x, y: ball.y };

  const ABx = B.x - A.x;
  const ABy = B.y - A.y;
  const APx = P.x - A.x;
  const APy = P.y - A.y;

  const abLenSq = ABx * ABx + ABy * ABy;
  const t = Math.max(0, Math.min(1, (APx * ABx + APy * ABy) / abLenSq));

  const closestX = A.x + ABx * t;
  const closestY = A.y + ABy * t;

  const dx = P.x - closestX;
  const dy = P.y - closestY;
  const distSq = dx * dx + dy * dy;

  if (distSq <= ballRadius * ballRadius) {
    const dist = Math.sqrt(distSq) || 1;
    const nx = dx / dist;
    const ny = dy / dist;

    const r = reflect(ball.vx, ball.vy, nx, ny);
    ball.vx = r.vx;
    ball.vy = r.vy;

    ball.x = closestX + nx * (ballRadius + 0.1);
    ball.y = closestY + ny * (ballRadius + 0.1);
  }
}

// Hypotenuse-only triangle collisions
function checkTriangleBounce() {
  checkLineCollision(0, triSize, triSize, 0);
  checkLineCollision(W - triSize, 0, W, triSize);
  checkLineCollision(0, H - triSize, triSize, H);
  checkLineCollision(W - triSize, H, W, H - triSize);
}

function rectCircleCollide(px, py, pw, ph, cx, cy, cr) {
  const testX = Math.max(px, Math.min(cx, px + pw));
  const testY = Math.max(py, Math.min(cy, py + ph));
  const distX = cx - testX;
  const distY = cy - testY;
  return (distX * distX + distY * distY) <= cr * cr;
}

function update() {
  if (paused) return;

  handleLeftPaddleInput();
  handleRightPaddleInput();
  updateAI();

  ball.x += ball.vx;
  ball.y += ball.vy;

  checkTriangleBounce();

  trail.push({ x: ball.x, y: ball.y, isPower: ball.isPower });
  if (trail.length > TRAIL_MAX_POINTS) trail.shift();

  if (ball.y - ballRadius < 0) {
    ball.y = ballRadius;
    ball.vy *= -1;
  }
  if (ball.y + ballRadius > H) {
    ball.y = H - ballRadius;
    ball.vy *= -1;
  }

  if (rectCircleCollide(leftPaddle.x, leftPaddle.y, paddleWidth, paddleHeight,
                        ball.x, ball.y, ballRadius)) {

    aiFrameCounter = 0;

    ball.x = leftPaddle.x + paddleWidth + ballRadius;
    ball.vx = Math.abs(ball.vx);

    leftScore += ball.isPower ? 2 : 1;

    setFlash('left', 'green');
    maybePowerShot();
  }

  if (rectCircleCollide(rightPaddle.x, rightPaddle.y, paddleWidth, paddleHeight,
                        ball.x, ball.y, ballRadius)) {

    aiFrameCounter = 0;

    ball.x = rightPaddle.x - ballRadius;
    ball.vx = -Math.abs(ball.vx);

    rightScore += ball.isPower ? 2 : 1;

    setFlash('right', 'green');
    maybePowerShot();
  }

  if (ball.x + ballRadius < 0) {
    setFlash('left', 'red');
    resetBall(true);
  }

  if (ball.x - ballRadius > W) {
    setFlash('right', 'red');
    resetBall(false);
  }

  const now = performance.now();
  if (leftFlash && now > leftFlash.until) leftFlash = null;
  if (rightFlash && now > rightFlash.until) rightFlash = null;
}

function drawArena() {
  if (leftFlash) {
    ctx.fillStyle = leftFlash.color;
    ctx.fillRect(0, 0, midX, H);
  } else {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, midX, H);
  }

  if (rightFlash) {
    ctx.fillStyle = rightFlash.color;
    ctx.fillRect(midX, 0, midX, H);
  } else {
    ctx.fillStyle = 'black';
    ctx.fillRect(midX, 0, midX, H);
  }

  ctx.strokeStyle = 'white';
  ctx.lineWidth = 2;
  ctx.strokeRect(0, 0, W, H);

  ctx.strokeStyle = 'red';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(midX, 0);
  ctx.lineTo(midX, H);
  ctx.stroke();

  ctx.fillStyle = 'white';

  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(triSize, 0);
  ctx.lineTo(0, triSize);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(W, 0);
  ctx.lineTo(W - triSize, 0);
  ctx.lineTo(W, triSize);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(0, H);
  ctx.lineTo(triSize, H);
  ctx.lineTo(0, H - triSize);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(W, H);
  ctx.lineTo(W - triSize, H);
  ctx.lineTo(W, H - triSize);
  ctx.fill();
}

function drawPaddles() {
  ctx.fillStyle = 'white';
  ctx.fillRect(leftPaddle.x, leftPaddle.y, paddleWidth, paddleHeight);
  ctx.fillRect(rightPaddle.x, rightPaddle.y, paddleWidth, paddleHeight);
}

function drawTrail() {
  for (let p of trail) {
    const dx = ball.x - p.x;
    const dy = ball.y - p.y;
    const dist = Math.hypot(dx, dy);
    if (dist > TRAIL_MAX_DIST) continue;

    const alpha = 1 - dist / TRAIL_MAX_DIST;
    if (p.isPower) ctx.fillStyle = `rgba(255,140,0,${alpha})`;
    else ctx.fillStyle = `rgba(147,112,219,${alpha})`;

    ctx.beginPath();
    ctx.arc(p.x, p.y, ballRadius * 0.9, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawBall() {
  ctx.fillStyle = ball.isPower ? 'orange' : 'blue';
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
  ctx.fill();
}

function drawScores() {
  ctx.fillStyle = 'white';
  ctx.font = '24px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';

  ctx.fillText(leftScore, midX / 2, 10);
  ctx.fillText(rightScore, midX + midX / 2, 10);
}

function loop() {
  update();
  drawArena();
  drawTrail();
  drawPaddles();
  drawBall();
  drawScores();
  requestAnimationFrame(loop);
}

// Buttons
slowBtn.onclick = () => {
  slowMode = !slowMode;
  slowBtn.classList.toggle('active', slowMode);
  updateBallSpeed();
};

twoPBtn.onclick = () => {
  twoPlayer = !twoPlayer;
  twoPBtn.classList.toggle('active', twoPlayer);
};

pauseBtn.onclick = () => {
  paused = !paused;
  pauseBtn.classList.toggle('active', paused);
};

resetBtn.onclick = () => {
  leftScore = 0;
  rightScore = 0;
  resetBall(true);
  resetBtn.classList.add('active');
  setTimeout(() => resetBtn.classList.remove('active'), 150);
};

resetBall(true);
loop();
</script>
</body>
</html>
