<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title> Super Pong</title>
<style>
  body {
    margin: 0;
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: white;
    font-family: Arial, sans-serif;
    user-select: none;
  }
  #gameContainer {
    margin-top: 10px;
    position: relative;
  }
  canvas {
    background: black;
    display: block;
  }
  #controls {
    margin-top: 10px;
    display: flex;
    gap: 10px;
  }
  .btn {
    padding: 6px 14px;
    background: blue;
    color: white;
    border: 2px solid white;
    cursor: pointer;
    font-weight: bold;
  }
  .btn.active {
    background: yellow;
    color: black;
  }
</style>
</head>
<body>
<h2>Custom Pong</h2>

<div id="controls">
  <button id="slowBtn" class="btn">Slow</button>
  <button id="twoPBtn" class="btn">2P</button>
  <button id="pauseBtn" class="btn">Pause</button>
  <button id="resetBtn" class="btn">Reset</button>
</div>

<div id="gameContainer">
  <canvas id="game" width="800" height="500"></canvas>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const W = canvas.width;
const H = canvas.height;
const midX = W / 2;

// Paddles
const paddleWidth = 12;
const paddleHeight = 80;
const paddleOffset = 5;
const paddleSpeed = 6;

// Ball
const ballRadius = 8;
const BASE_SPEED = 4;
const SLOW_SPEED = 2;
const FAST_SPEED = 8;
let slowMode = false;
let paused = false;
let twoPlayer = false;

let leftScore = 0;
let rightScore = 0;

let ball = {
  x: midX,
  y: H / 2,
  vx: BASE_SPEED,
  vy: 1.5,
  speed: BASE_SPEED,
  isPower: false
};

let leftPaddle = {
  x: paddleOffset,
  y: H / 2 - paddleHeight / 2,
  vy: paddleSpeed
};

let rightPaddle = {
  x: W - paddleOffset - paddleWidth,
  y: H / 2 - paddleHeight / 2,
  vy: paddleSpeed,
  targetY: H / 2,
  willHit: true
};

// Trail
const trail = [];
const TRAIL_MAX_POINTS = 30;
const TRAIL_MAX_DIST = 40;

// Flashes
let leftFlash = null;
let rightFlash = null;

// Buttons
const slowBtn = document.getElementById('slowBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const twoPBtn = document.getElementById('twoPBtn');

// Keyboard
const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

function clampPaddle(p) {
  if (p.y < 0) p.y = 0;
  if (p.y + paddleHeight > H) p.y = H - paddleHeight;
}

// LEFT PADDLE: W = up, D = down
function handleLeftPaddleInput() {
  if (keys['w'] || keys['W']) {
    leftPaddle.y -= leftPaddle.vy;
  }
  if (keys['d'] || keys['D']) {
    leftPaddle.y += leftPaddle.vy;
  }
  clampPaddle(leftPaddle);
}

// RIGHT PADDLE: Arrow keys ONLY when 2P mode is active
function handleRightPaddleInput() {
  if (!twoPlayer) return;

  if (keys['ArrowUp']) {
    rightPaddle.y -= rightPaddle.vy;
  }
  if (keys['ArrowDown']) {
    rightPaddle.y += rightPaddle.vy;
  }
  clampPaddle(rightPaddle);
}

// AI: 60% hit, 40% miss
function updateAI() {
  if (twoPlayer) return; // AI OFF in 2P mode

  if (ball.vx > 0 && ball.x > midX - 10) {
    if (Math.random() < 0.6) {
      rightPaddle.willHit = true;
      rightPaddle.targetY = ball.y - paddleHeight / 2;
    } else {
      rightPaddle.willHit = false;
      const offset = (Math.random() * 80 - 40);
      rightPaddle.targetY = ball.y - paddleHeight / 2 + offset;
    }
  }

  if (rightPaddle.targetY < rightPaddle.y) {
    rightPaddle.y -= rightPaddle.vy;
  } else if (rightPaddle.targetY > rightPaddle.y) {
    rightPaddle.y += rightPaddle.vy;
  }
  clampPaddle(rightPaddle);
}

function setFlash(side, color) {
  const until = performance.now() + 1000;
  if (side === 'left') leftFlash = { color, until };
  else rightFlash = { color, until };
}

function resetBall(toRight) {
  ball.x = midX;
  ball.y = H / 2;
  ball.isPower = false;
  ball.speed = slowMode ? SLOW_SPEED : BASE_SPEED;
  const angle = 0.3;
  ball.vx = (toRight ? 1 : -1) * ball.speed * Math.cos(angle);
  ball.vy = ball.speed * Math.sin(angle);
  trail.length = 0;
}

function updateBallSpeed() {
  if (ball.isPower) ball.speed = FAST_SPEED;
  else ball.speed = slowMode ? SLOW_SPEED : BASE_SPEED;

  const mag = Math.hypot(ball.vx, ball.vy) || 1;
  ball.vx = (ball.vx / mag) * ball.speed;
  ball.vy = (ball.vy / mag) * ball.speed;
}

function maybePowerShot() {
  ball.isPower = Math.random() < 0.3;
  updateBallSpeed();
}

function rectCircleCollide(px, py, pw, ph, cx, cy, cr) {
  const testX = Math.max(px, Math.min(cx, px + pw));
  const testY = Math.max(py, Math.min(cy, py + ph));
  const distX = cx - testX;
  const distY = cy - testY;
  return (distX * distX + distY * distY) <= cr * cr;
}

function update() {
  if (paused) return;

  handleLeftPaddleInput();
  handleRightPaddleInput();
  updateAI();

  ball.x += ball.vx;
  ball.y += ball.vy;

  trail.push({ x: ball.x, y: ball.y, isPower: ball.isPower });
  if (trail.length > TRAIL_MAX_POINTS) trail.shift();

  if (ball.y - ballRadius < 0) {
    ball.y = ballRadius;
    ball.vy *= -1;
  }
  if (ball.y + ballRadius > H) {
    ball.y = H - ballRadius;
    ball.vy *= -1;
  }

  if (rectCircleCollide(leftPaddle.x, leftPaddle.y, paddleWidth, paddleHeight,
                        ball.x, ball.y, ballRadius)) {
    ball.x = leftPaddle.x + paddleWidth + ballRadius;
    ball.vx = Math.abs(ball.vx);
    leftScore++;
    setFlash('left', 'green');
    maybePowerShot();
  }

  if (rectCircleCollide(rightPaddle.x, rightPaddle.y, paddleWidth, paddleHeight,
                        ball.x, ball.y, ballRadius)) {
    ball.x = rightPaddle.x - ballRadius;
    ball.vx = -Math.abs(ball.vx);
    rightScore++;
    setFlash('right', 'green');
    maybePowerShot();
  }

  if (ball.x + ballRadius < 0) {
    setFlash('left', 'red');
    resetBall(true);
  }

  if (ball.x - ballRadius > W) {
    setFlash('right', 'red');
    resetBall(false);
  }

  const now = performance.now();
  if (leftFlash && now > leftFlash.until) leftFlash = null;
  if (rightFlash && now > rightFlash.until) rightFlash = null;
}

function drawArena() {
  if (leftFlash) {
    ctx.fillStyle = leftFlash.color;
    ctx.fillRect(0, 0, midX, H);
  } else {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, midX, H);
  }

  if (rightFlash) {
    ctx.fillStyle = rightFlash.color;
    ctx.fillRect(midX, 0, midX, H);
  } else {
    ctx.fillStyle = 'black';
    ctx.fillRect(midX, 0, midX, H);
  }

  ctx.strokeStyle = 'white';
  ctx.lineWidth = 2;
  ctx.strokeRect(0, 0, W, H);

  ctx.strokeStyle = 'red';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(midX, 0);
  ctx.lineTo(midX, H);
  ctx.stroke();

  ctx.fillStyle = 'white';
  const triSize = 20;

  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(triSize, 0);
  ctx.lineTo(0, triSize);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(W, 0);
  ctx.lineTo(W - triSize, 0);
  ctx.lineTo(W, triSize);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(0, H);
  ctx.lineTo(triSize, H);
  ctx.lineTo(0, H - triSize);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(W, H);
  ctx.lineTo(W - triSize, H);
  ctx.lineTo(W, H - triSize);
  ctx.fill();
}

function drawPaddles() {
  ctx.fillStyle = 'white';
  ctx.fillRect(leftPaddle.x, leftPaddle.y, paddleWidth, paddleHeight);
  ctx.fillRect(rightPaddle.x, rightPaddle.y, paddleWidth, paddleHeight);
}

function drawTrail() {
  for (let p of trail) {
    const dx = ball.x - p.x;
    const dy = ball.y - p.y;
    const dist = Math.hypot(dx, dy);
    if (dist > TRAIL_MAX_DIST) continue;

    const alpha = 1 - dist / TRAIL_MAX_DIST;
    if (p.isPower) ctx.fillStyle = `rgba(255,140,0,${alpha})`;
    else ctx.fillStyle = `rgba(147,112,219,${alpha})`;

    ctx.beginPath();
    ctx.arc(p.x, p.y, ballRadius * 0.9, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawBall() {
  ctx.fillStyle = ball.isPower ? 'orange' : 'blue';
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
  ctx.fill();
}

function drawScores() {
  ctx.fillStyle = 'white';
  ctx.font = '24px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';

  ctx.fillText(leftScore, midX / 2, 10);
  ctx.fillText(rightScore, midX + midX / 2, 10);
}

function loop() {
  update();
  drawArena();
  drawTrail();
  drawPaddles();
  drawBall();
  drawScores();
  requestAnimationFrame(loop);
}

// Buttons
slowBtn.onclick = () => {
  slowMode = !slowMode;
  slowBtn.classList.toggle('active', slowMode);
  updateBallSpeed();
};

twoPBtn.onclick = () => {
  twoPlayer = !twoPlayer;
  twoPBtn.classList.toggle('active', twoPlayer);
};

pauseBtn.onclick = () => {
  paused = !paused;
  pauseBtn.classList.toggle('active', paused);
};

resetBtn.onclick = () => {
  leftScore = 0;
  rightScore = 0;
  resetBall(true);
  resetBtn.classList.add('active');
  setTimeout(() => resetBtn.classList.remove('active'), 150);
};

resetBall(true);
loop();
</script>
</body>
</html>
