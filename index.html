<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Super Pong</title>
<style>
  body {
    margin: 0;
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: white;
    font-family: Arial, sans-serif;
    overflow: hidden; /* Prevent scrolling */
    user-select: none;
  }

  #gameWrapper {
    position: relative;
    transform-origin: top center;
  }

  #gameContainer {
    margin-top: 10px;
    position: relative;
    width: 800px;
    height: 500px;
  }

  canvas {
    background: black;
    display: block;
  }

  #controls {
    margin-top: 10px;
    display: flex;
    gap: 10px;
  }

  .btn {
    padding: 6px 14px;
    background: blue;
    color: white;
    border: 2px solid white;
    cursor: pointer;
    font-weight: bold;
  }

  .btn.active {
    background: yellow;
    color: black;
  }

  /* Floating Speed Indicator */
  #speedIndicator {
    position: absolute;
    left: -120px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 22px;
    font-weight: bold;
    color: white;
    pointer-events: none;
  }
</style>
</head>
<body>
<h2>Super Pong</h2>

<div id="controls">
  <button id="slowBtn" class="btn">Slow</button>
  <button id="twoPBtn" class="btn">2P</button>
  <button id="pauseBtn" class="btn">Pause</button>
  <button id="fastBtn" class="btn">Fast</button>
  <button id="resetBtn" class="btn">Reset</button>
</div>

<!-- Wrapper for scaling -->
<div id="gameWrapper">
  <div id="gameContainer">
    <div id="speedIndicator">Normal</div>
    <canvas id="game" width="800" height="500"></canvas>
  </div>
</div>

<script>
/* ------------------ AUTO-DETECT ORIENTATION SCALING ------------------ */

function scaleGame() {
  const wrapper = document.getElementById("gameWrapper");

  const gameWidth = 800;
  const gameHeight = 500;

  const availableWidth = window.innerWidth;
  const availableHeight = window.innerHeight - 120; // space for buttons + title

  const scaleX = availableWidth / gameWidth;
  const scaleY = availableHeight / gameHeight;

  const scale = Math.min(scaleX, scaleY);

  wrapper.style.transform = `scale(${scale})`;
}

window.addEventListener("resize", scaleGame);
window.addEventListener("orientationchange", scaleGame);
window.addEventListener("load", scaleGame);

/* ------------------ GAME LOGIC BELOW (unchanged except AI + speed indicator) ------------------ */

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const W = canvas.width;
const H = canvas.height;
const midX = W / 2;

const triSize = 20;

const paddleWidth = 12;
const paddleHeight = 80;
const paddleOffset = 5;
const paddleSpeed = 6;
const aiSpeed = paddleSpeed - 1;

const ballRadius = 8;
const BASE_SPEED = 4;
const FAST_MODE_SPEED = 6;
const SLOW_SPEED = 2;
const FIREBALL_SPEED = 8;

let slowMode = false;
let fastMode = false;
let paused = false;
let twoPlayer = false;

let leftScore = 0;
let rightScore = 0;

let ball = {
  x: midX,
  y: H / 2,
  vx: BASE_SPEED,
  vy: 1.5,
  speed: BASE_SPEED,
  isPower: false
};

let leftPaddle = {
  x: paddleOffset,
  y: H / 2 - paddleHeight / 2,
  vy: paddleSpeed
};

let rightPaddle = {
  x: W - paddleOffset - paddleWidth,
  y: H / 2 - paddleHeight / 2,
  vy: aiSpeed,
  targetY: H / 2
};

let aiFrameCounter = 0;

const trail = [];
const TRAIL_MAX_POINTS = 30;
const TRAIL_MAX_DIST = 40;

let leftFlash = null;
let rightFlash = null;

const slowBtn = document.getElementById('slowBtn');
const fastBtn = document.getElementById('fastBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const twoPBtn = document.getElementById('twoPBtn');

const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

function clampPaddle(p) {
  if (p.y < triSize) p.y = triSize;
  if (p.y + paddleHeight > H - triSize) p.y = H - triSize - paddleHeight;
}

function handleLeftPaddleInput() {
  if (keys['w'] || keys['W']) leftPaddle.y -= leftPaddle.vy;
  if (keys['d'] || keys['D']) leftPaddle.y += leftPaddle.vy;
  clampPaddle(leftPaddle);
}

function handleRightPaddleInput() {
  if (!twoPlayer) return;

  if (keys['ArrowLeft']) rightPaddle.y -= rightPaddle.vy;
  if (keys['ArrowRight']) rightPaddle.y += rightPaddle.vy;

  clampPaddle(rightPaddle);
}

function updateAI() {
  if (twoPlayer) return;

  if (ball.vx > 0) {
    aiFrameCounter++;

    if (aiFrameCounter >= 20) {
      aiFrameCounter = 0;

      if (Math.random() < 0.55) {
        rightPaddle.targetY = ball.y - paddleHeight / 2;
      } else {
        rightPaddle.targetY = ball.y - paddleHeight / 2 + (Math.random() * 80 - 40);
      }
    }
  }

  if (rightPaddle.targetY < rightPaddle.y) rightPaddle.y -= rightPaddle.vy;
  else if (rightPaddle.targetY > rightPaddle.y) rightPaddle.y += rightPaddle.vy;

  clampPaddle(rightPaddle);
}

function setFlash(side, color) {
  const until = performance.now() + 1000;
  if (side === 'left') leftFlash = { color, until };
  else rightFlash = { color, until };
}

function resetBall(toRight) {
  ball.x = midX;
  ball.y = H / 2;
  ball.isPower = false;
  aiFrameCounter = 0;

  updateBallSpeed();

  const angle = 0.3;
  ball.vx = (toRight ? 1 : -1) * ball.speed * Math.cos(angle);
  ball.vy = ball.speed * Math.sin(angle);

  trail.length = 0;
}

function updateBallSpeed() {
  if (ball.isPower) {
    ball.speed = FIREBALL_SPEED;
  } else {
    if (fastMode) ball.speed = FAST_MODE_SPEED;
    else if (slowMode) ball.speed = SLOW_SPEED;
    else ball.speed = BASE_SPEED;
  }

  const mag = Math.hypot(ball.vx, ball.vy) || 1;
  ball.vx = (ball.vx / mag) * ball.speed;
  ball.vy = (ball.vy / mag) * ball.speed;
}

function maybePowerShot() {
  ball.isPower = Math.random() < 0.2;
  updateBallSpeed();
}

function reflect(vx, vy, nx, ny) {
  const dot = vx * nx + vy * ny;
  return { vx: vx - 2 * dot * nx, vy: vy - 2 * dot * ny };
}

function checkLineCollision(x1, y1, x2, y2) {
  const A = { x: x1, y: y1 };
  const B = { x: x2, y: y2 };
  const P = { x: ball.x, y: ball.y };

  const ABx = B.x - A.x;
  const ABy = B.y - A.y;
  const APx = P.x - A.x;
  const APy = P.y - A.y;

  const abLenSq = ABx * ABx + ABy * ABy;
  const t = Math.max(0, Math.min(1, (APx * ABx + APy * ABy) / abLenSq));

  const closestX = A.x + ABx * t;
  const closestY = A.y + ABy * t;

  const dx = P.x - closestX;
  const dy = P.y - closestY;

  if (dx * dx + dy * dy <= ballRadius * ballRadius) {
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
    const nx = dx / dist;
    const ny = dy / dist;

    const r = reflect(ball.vx, ball.vy, nx, ny);
    ball.vx = r.vx;
    ball.vy = r.vy;

    ball.x = closestX + nx * (ballRadius + 0.1);
    ball.y = closestY + ny * (ballRadius + 0.1);
  }
}

function checkTriangleBounce() {
  checkLineCollision(0, triSize, triSize, 0);
  checkLineCollision(W - triSize, 0, W, triSize);
  checkLineCollision(0, H - triSize, triSize, H);
  checkLineCollision(W - triSize, H, W, H - triSize);
}

function rectCircleCollide(px, py, pw, ph, cx, cy, cr) {
  const testX = Math.max(px, Math.min(cx, px + pw));
  const testY = Math.max(py, Math.min(cy, py + ph));
  const dx = cx - testX;
  const dy = cy - testY;
  return dx * dx + dy * dy <= cr * cr;
}

function update() {
  if (paused) return;

  handleLeftPaddleInput();
  handleRightPaddleInput();
  updateAI();

  ball.x += ball.vx;
  ball.y += ball.vy;

  checkTriangleBounce();

  trail.push({ x: ball.x, y: ball.y, isPower: ball.isPower });
  if (trail.length > TRAIL_MAX_POINTS) trail.shift();

  if (ball.y - ballRadius < 0) {
    ball.y = ballRadius;
    ball.vy *= -1;
  }
  if (ball.y + ballRadius > H) {
    ball.y = H - ballRadius;
    ball.vy *= -1;
  }

  if (rectCircleCollide(leftPaddle.x, leftPaddle.y, paddleWidth, paddleHeight,
                        ball.x, ball.y, ballRadius)) {

    aiFrameCounter = 0;

    ball.x = leftPaddle.x + paddleWidth + ballRadius;
    ball.vx = Math.abs(ball.vx);

    leftScore += ball.isPower ? 2 : 1;

    setFlash('left', 'green');
    maybePowerShot();
  }

  if (rectCircleCollide(rightPaddle.x, rightPaddle.y, paddleWidth, paddleHeight,
                        ball.x, ball.y, ballRadius)) {

    aiFrameCounter = 0;

    ball.x = rightPaddle.x - ballRadius;
    ball.vx = -Math.abs(ball.vx);

    rightScore += ball.isPower ? 2 : 1;

    setFlash('right', 'green');
    maybePowerShot();
  }

  if (ball.x + ballRadius < 0) {
    setFlash('left', 'red');
    resetBall(true);
  }

  if (ball.x - ballRadius > W) {
    setFlash('right', 'red');
    resetBall(false);
  }

  const now = performance.now();
  if (leftFlash && now > leftFlash.until) leftFlash = null;
  if (rightFlash && now > rightFlash.until) rightFlash = null;
}

function drawArena() {
  if (leftFlash) {
    ctx.fillStyle = leftFlash.color;
    ctx.fillRect(0, 0, midX, H);
  } else {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, midX, H);
  }

  if (rightFlash) {
    ctx.fillStyle = rightFlash.color;
    ctx.fillRect(midX, 0, midX, H);
  } else {
    ctx.fillStyle = 'black';
    ctx.fillRect(midX, 0, midX, H);
  }

  ctx.strokeStyle = 'white';
  ctx.lineWidth = 2;
  ctx.strokeRect(0, 0, W, H);

  ctx.strokeStyle = 'red';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(midX, 0);
  ctx.lineTo(midX, H);
  ctx.stroke();

  ctx.fillStyle = 'white';

  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(triSize, 0);
  ctx.lineTo(0, triSize);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(W, 0);
  ctx.lineTo(W - triSize, 0);
  ctx.lineTo(W, triSize);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(0, H);
  ctx.lineTo(triSize, H);
  ctx.lineTo(0, H - triSize);
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(W, H);
  ctx.lineTo(W - triSize, H);
  ctx.lineTo(W, H - triSize);
  ctx.fill();
}

function drawPaddles() {
  ctx.fillStyle = 'white';
  ctx.fillRect(leftPaddle.x, leftPaddle.y, paddleWidth, paddleHeight);
  ctx.fillRect(rightPaddle.x, rightPaddle.y, paddleWidth, paddleHeight);
}

function drawTrail() {
  for (let p of trail) {
    const dx = ball.x - p.x;
    const dy = ball.y - p.y;
    const dist = Math.hypot(dx, dy);
    if (dist > TRAIL_MAX_DIST) continue;

    const alpha = 1 - dist / TRAIL_MAX_DIST;
    ctx.fillStyle = p.isPower
      ? `rgba(255,140,0,${alpha})`
      : `rgba(147,112,219,${alpha})`;

    ctx.beginPath();
    ctx.arc(p.x, p.y, ballRadius * 0.9, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawBall() {
  ctx.fillStyle = ball.isPower ? 'orange' : 'blue';
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
  ctx.fill();
}

function drawScores() {
  ctx.fillStyle = 'white';
  ctx.font = '24px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';

  ctx.fillText(leftScore, midX / 2, 10);
  ctx.fillText(rightScore, midX + midX / 2, 10);
}

function updateSpeedIndicator() {
  const indicator = document.getElementById('speedIndicator');

  if (ball.isPower) {
    indicator.textContent = "Super";
    indicator.style.color = "orange";
  } else if (fastMode) {
    indicator.textContent = "Fast";
    indicator.style.color = "red";
  } else if (slowMode) {
    indicator.textContent = "Slow";
    indicator.style.color = "yellow";
  } else {
    indicator.textContent = "Normal";
    indicator.style.color = "white";
  }
}

function loop() {
  update();
  updateSpeedIndicator();
  drawArena();
  drawTrail();
  drawPaddles();
  drawBall();
  drawScores();
  requestAnimationFrame(loop);
}

slowBtn.onclick = () => {
  slowMode = !slowMode;
  slowBtn.classList.toggle('active', slowMode);
  updateBallSpeed();
};

fastBtn.onclick = () => {
  fastMode = !fastMode;
  fastBtn.classList.toggle('active', fastMode);
  updateBallSpeed();
};

twoPBtn.onclick = () => {
  twoPlayer = !twoPlayer;
  twoPBtn.classList.toggle('active', twoPlayer);
};

pauseBtn.onclick = () => {
  paused = !paused;
  pauseBtn.classList.toggle('active', paused);
};

resetBtn.onclick = () => {
  leftScore = 0;
  rightScore = 0;
  resetBall(true);
  resetBtn.classList.add('active');
  setTimeout(() => resetBtn.classList.remove('active'), 150);
};

resetBall(true);
loop();
</script>
</body>
</html>
